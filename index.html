<!DOCTYPE html>
<html lang="en">
<head>
	<title>Shower asd Presentation Engine</title>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="node_modules/shower-ribbon/styles/screen-16x10.css">
</head>
<body class="shower list">

	<header class="caption">
		<h1>Angular + RxJS = BFF</h1>
	</header>

	<section class="slide" id="cover">
		<div class="wrapper">
			<img src="/pictures/angular.svg" alt="angular logo" class="cover__logo">
			<span class="plus">+</span>
			<img src="/pictures/rx.png" alt="rx logo" class="cover__logo">
		</div>
		<p>Best Friends Forever</p>
		<style>
			#cover {
				background-color: #1976d2;
			}
			#cover .wrapper {
				display: flex;
				justify-content: space-around;
			}
			#cover .wrapper span {
				color:#FFF;
				text-align:center;
				font-size:60px;
				align-self: center;
			}
			#cover .wrapper img{
				width: 200px;
				height: 200px;
			}
			#cover p {
				margin:10px 0 0;
				text-align:center;
				color:#FFF;
				font-size:70px;
				text-transform: uppercase;
				}
		</style>
	</section>

	<section class="slide">
		<ul class="questions">
			<li>Кто слышал о Реактивном программировании?</li>
			<li class="next">Кто использует Rx в продакшене?</li>
			<li class="next">Кто использует что-то большее, чем HttpClientModule?</li>
		</ul>
		<style>
			.questions li {
				font-size: 35px;
			}
		</style>
	</section>

	<section class="slide black">
		<figure>
			<img class="fullscreen" src="/pictures/rxcover.jpg" alt="Photo of night road">
			<figcaption>
				<p class="rx-def">An Api for asynchronous programming with observable streams</p>
			</figcaption>
		</figure>
		<style>
			.fullscreen {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%,-50%);
			}
			.rx-def {
				position: relative;
				z-index: 2;
				color: #fff;
				font-size: 40px;
				text-align: center;
				margin-top: 10%;
			}
		</style>
	</section>

	<!-- mb slide with screen from presentalional mode of webstorm is better-->
			<!--interface Observer<T> {-->
					<!--next: (value: T) => void;-->
					<!--error: (err: any) => void;-->
					<!--complete: () => void;-->
				<!--}-->
	<section class="slide ">
		<pre>
			<code class="obs-callback" style="margin-left: -180px; margin-top: -60px;padding: 0;line-height: 1;">
				const observarble = {
					subscribe: function subscribe(ob) {
						[10,20,30].forEach(ob.next);
						ob.complete();
					},
				}

				const observer = {
					next: function nextCallback(data) {
						// do something on each data portion
					},
					error: function errorCallback(err) {
						// dp smth on error
					},
					complete: function completeCallback() {
						// end of stream
					}
				}

				observable.subscribe(observer);
			</code>
		</pre>
	</section>

	<section class="slide">
		<ol class="pros">
			<li>Build-in for Angular</li>
			<li class="next">Best practice and code examples from framework</li>
			<li class="next">Consistency of code base</li>
			<li class="next">Ubiquitous - RX is everywhere, and it's meant for everything.</li>
		</ol>
		<style>
			.pros li {
				font-size: 35px;
			}
		</style>
	</section>

	<section class="slide">
		<h2>Autocomplete component</h2>
		<video src="pictures/giphy.mp4" autoplay></video>
	</section>

	<section class="slide">
		<h2>Slide with icons of autocomplete plan</h2>
	</section>

	<section class="slide">
		<pre>
			<code style="margin-left: -190px; margin-top: -60px;padding: 0;">
				const input$ = Rx.Observable
					.fromEvent(inputElement, 'change')
					.map(element => element.target.value)
					.filter(text => text.length >= 3)
					.debounce(500)
					.distinctUntilChanged()
					.switchMap(val => httpClineModule.getData('url'));
			</code>
		</pre>
	</section>

	<!-- not actual slide -->
	<section class="slide">
		И казалось бы - вот оно счастье.
		Компонент автокомплита, не самой сложной, но и не самой тривиальной задачи
		всего в 7 строк, но нет. Еще одна прелесть, которая иногда смущает и вызывает вопросы новичков в Рх
		- почему эти 7 строк не генерят запрос.
		А все дело в том, что обз - ленивые по своей сути. пока нет ниодного подписчика,
		т.е. никому показывать дату - никто не будет за ней ходить.
	</section>

	<section class="slide">
		<pre>
			<code style="margin-left: -190px; margin-top: -80px;padding: 0;">
				const input$ = Rx.Observable
					.fromEvent(inputElement, 'change')
					.map(element => element.target.value)
					.filter(text => text.length >= 3)
					.debounce(500)
					.distinctUntilChanged()
					.switchMap(val => httpClineModule.getData('url'));
			</code>
		</pre>
		<pre>
			<code style="    margin-top: -130px; margin-left: -130px; color: green; padding: 0">
				.subscribe(
					(receivedData) => { this.data = receivedData;},
					(err) => { handleError(err); });</code>
		</pre>
	</section>

	<section class="slide">
		<h2>Async pipe</h2>
		<p>The async pipe subscribes to an Observable or Promise and returns the latest value it has emitted.
			When a new value is emitted, the async pipe marks the component to be checked for changes.
			When the component gets destroyed, the async pipe unsubscribes automatically to avoid potential memory leaks.</p>
	</section>

	<section class="slide">
		<pre>
			<code style="padding: 0;margin-left: -250px;margin-top: 40px;">
				&lt;ul&gt;
					&lt;li *ngFor="r of results$ | async"&gt; {{r.name}}&lt;/li&gt;
				&lt;/ul&gt;
			</code>
		</pre>
	</section>

	<section class="slide">
		<pre>
			<code style="    padding: 0;margin-left: -250px;">
				&lt;div&gt;
					&lt;h3&gt;User Profile&lt;/h3&gt;
					&lt;span&gt;{{ (user$ | async)?.name }}&lt;/span&gt;
					&lt;span&gt;{{ (user$ | async)?.id }}&lt;/span&gt;
					&lt;img [src]="(user$ | async)?.profile_image"&gt;
				&lt;/div&gt;
			</code>
		</pre>
	</section>

	<!-- mb some joke for dumb and smart components-->

	<section class="slide">
		<pre>
			<code style="padding: 0;margin-left: -250px;margin-top: -80px;">
				&lt;div&gt;
					&lt;h3&gt;User Profile&lt;/h3&gt;
					&lt;span&gt;{{ user.name }}&lt;/span&gt;
					&lt;span&gt;{{ user.id }}&lt;/span&gt;
					&lt;img [src]="user.profile_image"&gt;
				&lt;/div&gt;
			</code>
		</pre>

		<pre>
			<code style="padding: 0; margin-left: -250px;margin-top: -60px;">
				export class ProfileComponent {
					@Input() user: User = {};
				}
			</code>
		</pre>
	</section>

	<section class="slide">
		<pre>
			<code style="padding: 0;margin-left: -250px;margin-top: 60px;">
				&lt;user-profile [user]="user$ | async"&gt;&lt;/user-profile&gt;
			</code>
		</pre>
	</section>

	<section class="slide">
		<!-- и чтобы далеко не уходить от хттпКлиентМодуля давайте заглянем внутрь.
		Если честно, то в ХттпМодуле было полегче разобраться, но теперь он спроектирован куда лучше.
		код -> и что можем для себя забрать из такого с первого вида простого кода
		-
		-
		-->
	</section>

	<section class="slide">
		<h2>Промежуточные выводы</h2>
		<ol>
			<li></li>
			<li></li>
			<li></li>
			<li><li>
		</ol>
	</section>

<!-- start event bus -->
	<section class="slide">
		<div id="parent-ee">
		  <div class="first">
		    <span>1</span>
		  </div>
		  <div class="second">
		    <span>2</span>
		  </div>
		</div>
		<p class="next" style="text-align: center; margin-top: 50px;font-size: 40px;">EventEmitters, @Input(), @Output()</p>
		<style>
		#parent-ee {
    	width: 70%;
			margin-left: auto;
  		margin-right: auto;
		  background-color: lightgrey;
		  display: flex;
		  padding: 50px;
		  justify-content: space-between;
		}

		#parent-ee div {
			width: 40%;
			min-height: 200px;
		  display: flex;
		  justify-content: center;
		  align-items: center;
		  color: white;
		}

		#parent-ee .first {
		  background-color: red;
		}

		#parent-ee .second {
		  background-color: blue;
		}
		</style>
	</section>

	<section class="slide">
		<div id="parent-s">
		  <div class="inter-parent">
		    <div class="first">
		      <span>1</span>
		    </div>
		  </div>
		  <div class="inter-parent">
		    <div class="second">
		      <span>2</span>
		    </div>
		  </div>
		</div>
		<p class="next" style="text-align: center; margin-top: 50px;font-size: 40px;">Singleton Service with getters/setters</p>
		<style>
		#parent-s {
			width: 80%;
			min-width: 560px;
			min-height: 350px;
			margin-left: auto;
  		margin-right: auto;
		  background-color: lightgrey;
		  display: flex;
		  padding: 50px;
		  justify-content: space-between;
		}

		#parent-s .inter-parent {
			width: 46%;
		  /* height: 300px; */
		  display: flex;
		  justify-content: center;
		  align-items: center;
		  background-color: lightyellow;
		}

		#parent-s .first, #parent-s .second {
		  width: 80%;
			min-height: 200px;
		  height: 100px;
		  display: flex;
		  justify-content: center;
		  align-items: center;
		  color: white;
		}

		#parent-s .first {
		  background-color: red;
		}

		#parent-s .second {
		  background-color: blue;
		}
		</style>
	</section>

	<section class="slide">
		<!-- image with earth and mars -->
		<!-- redux or something other for state/data managment -->
	</section>

	<!-- можем снова использовать сервисы,
	но если придется обрабатывать дату на лету,
	да еще и по разному, то придется писать достаточно много методов чем-то.
	Естественно я бы не приводил такую задачу, если бы в ее контексте нельзя
	было использовать красивое решение с RxJS. В первом ангуляре была концепция
	общения контроллеров через события. выглядело это примерно таким образом
 -->

	<section class="slide">
		<pre>
			<code style="padding: 0; margin-left: -250px;">
				$scope.$emit(name, args); (to parent scope)
				$scope.$broadcast(name, args); (to child scope)
				$scope.$on(name, listener);
			</code>
			<code class="next br" style="padding: 0; margin-left: -250px;">
				$rootScope.$broadcast(name, args);
			</code>
		</pre>
		<style>
			.br {
				padding: 0;
				margin-left: -250px;
			}
			.br::before {
				display: none;
			}
		</style>
	</section>

	<section class="slide">
		<pre>
			<code style="padding: 0;">
				interface BroadcastEvent {
				  key: any;
				  data?: any;
				}
			</code>
		</pre>
	</section>


	<section class="slide">
		<pre>
			<code style="padding: 0;margin-left: -30%;margin-top: -8%;line-height: 1.5;">
				export class Broadcaster {
						private _eventBus: Subject<BroadcastEvent> = new Subject<BroadcastEvent>();

						broadcast(key: any, data?: any) {
							this._eventBus.next({key, data});
						}

						on<T>(key: any): Observable<T> {
							return this._eventBus.asObservable()
								.filter(event => event.key === key)
							 	.map(event => <T>event.data);
					 	}
				}
			</code>
		</pre>
	</section>

	<!-- ngRx -->
	<section class="slide">
		<figure>
			<blockquote>
				<p>The Last Piece in the Angular Architecture Puzzle.</p>
			</blockquote>
			<figcaption>Asim Hussain</figcaption>
		</figure>
	</section>



	<section class="slide" id="picture">
		<h2>Pictures</h2>
		<figure>
			<img class="cover" src="pictures/picture.jpg" alt="Orange typewriter on a wooden table close-up">
			<figcaption class="white">
				<a href="http://fiftyfootshadows.net/">© John Carey</a>
			</figcaption>
		</figure>
		<style>
			#picture h2 {
				color:#FFF;
				}
		</style>
	</section>

	<section class="slide">
		<h2 class="shout shrink">You can even shout this way</h2>
	</section>


	<section class="slide" id="see-more">
		<h2 class="shout">
			<img src="pictures/logo.svg" alt="Shower logo">
			<a href="https://github.com/shower/shower">See more on GitHub</a>
		</h2>
		<style>
			#see-more h2 {
				font-size:100px
				}
			#see-more img {
				width:0.72em;
				height:0.72em;
				}
		</style>
	</section>

	<footer class="badge">
		<a href="https://github.com/shower/shower">Fork me on GitHub</a>
	</footer>

	<div class="progress"></div>

	<script src="node_modules/shower-core/shower.min.js"></script>
	<!-- Copyright © 2017 Yours Truly, Famous Inc. -->

</body>
</html>
